"""Schema parity tests â€” ensure SQLite and PostgreSQL schemas stay in sync.

Parses both schema files via regex and asserts identical table names and
column definitions, accounting for expected syntax differences
(AUTOINCREMENT vs GENERATED BY DEFAULT AS IDENTITY, datetime('now') vs
CURRENT_TIMESTAMP, etc.).
"""

import re
from pathlib import Path

import pytest

PROJECT_ROOT = Path(__file__).resolve().parent.parent
SQLITE_SCHEMA = PROJECT_ROOT / "schema.sql"
POSTGRES_SCHEMA = PROJECT_ROOT / "schema.postgres.sql"

EXPECTED_TABLE_COUNT = 57

# Lines starting with these tokens inside a CREATE TABLE block are constraints,
# not column definitions.
_NON_COLUMN_PREFIXES = (
    "UNIQUE",
    "CHECK",
    "CONSTRAINT",
    "CREATE",
    "PRIMARY KEY",
    "FOREIGN KEY",
)


def _extract_tables(sql: str) -> dict[str, list[str]]:
    """Return {table_name: [col_name, ...]} parsed from a schema file."""
    tables: dict[str, list[str]] = {}

    # Match CREATE TABLE IF NOT EXISTS <name> ( ... );
    table_pattern = re.compile(
        r"CREATE\s+TABLE\s+IF\s+NOT\s+EXISTS\s+(\w+)\s*\((.*?)\);",
        re.DOTALL | re.IGNORECASE,
    )

    for match in table_pattern.finditer(sql):
        table_name = match.group(1)
        body = match.group(2)
        columns: list[str] = []

        for line in body.split("\n"):
            stripped = line.strip().rstrip(",")
            if not stripped:
                continue
            # Skip non-column lines (constraints, etc.)
            upper = stripped.upper().lstrip()
            if any(upper.startswith(prefix) for prefix in _NON_COLUMN_PREFIXES):
                continue
            # First word is the column name
            col_match = re.match(r"(\w+)", stripped)
            if col_match:
                columns.append(col_match.group(1).lower())

        tables[table_name.lower()] = columns

    return tables


# ---------------------------------------------------------------------------
# Tests
# ---------------------------------------------------------------------------


class TestSchemaParity:
    @pytest.fixture(autouse=True)
    def load_schemas(self):
        self.sqlite_sql = SQLITE_SCHEMA.read_text(encoding="utf-8")
        self.pg_sql = POSTGRES_SCHEMA.read_text(encoding="utf-8")
        self.sqlite_tables = _extract_tables(self.sqlite_sql)
        self.pg_tables = _extract_tables(self.pg_sql)

    def test_sqlite_schema_file_exists(self):
        assert SQLITE_SCHEMA.exists(), f"Missing {SQLITE_SCHEMA}"

    def test_postgres_schema_file_exists(self):
        assert POSTGRES_SCHEMA.exists(), f"Missing {POSTGRES_SCHEMA}"

    def test_sqlite_has_expected_table_count(self):
        assert len(self.sqlite_tables) == EXPECTED_TABLE_COUNT, (
            f"SQLite schema has {len(self.sqlite_tables)} tables, expected {EXPECTED_TABLE_COUNT}. "
            f"Tables: {sorted(self.sqlite_tables.keys())}"
        )

    def test_postgres_has_expected_table_count(self):
        assert len(self.pg_tables) == EXPECTED_TABLE_COUNT, (
            f"PostgreSQL schema has {len(self.pg_tables)} tables, expected {EXPECTED_TABLE_COUNT}. "
            f"Tables: {sorted(self.pg_tables.keys())}"
        )

    def test_table_names_match(self):
        sqlite_names = set(self.sqlite_tables.keys())
        pg_names = set(self.pg_tables.keys())

        only_sqlite = sqlite_names - pg_names
        only_pg = pg_names - sqlite_names

        assert sqlite_names == pg_names, (
            f"Table name mismatch.\n"
            f"Only in SQLite: {sorted(only_sqlite)}\n"
            f"Only in PostgreSQL: {sorted(only_pg)}"
        )

    def test_column_names_match_per_table(self):
        common_tables = set(self.sqlite_tables.keys()) & set(self.pg_tables.keys())
        mismatches: list[str] = []

        for table in sorted(common_tables):
            sqlite_cols = self.sqlite_tables[table]
            pg_cols = self.pg_tables[table]

            if sqlite_cols != pg_cols:
                only_sqlite = set(sqlite_cols) - set(pg_cols)
                only_pg = set(pg_cols) - set(sqlite_cols)
                msg = f"  {table}: "
                if only_sqlite:
                    msg += f"only in SQLite={sorted(only_sqlite)} "
                if only_pg:
                    msg += f"only in PostgreSQL={sorted(only_pg)} "
                if not only_sqlite and not only_pg:
                    # Same columns but different order
                    msg += f"column order differs: SQLite={sqlite_cols} PG={pg_cols}"
                mismatches.append(msg)

        assert not mismatches, f"Column mismatches in {len(mismatches)} table(s):\n" + "\n".join(
            mismatches
        )
